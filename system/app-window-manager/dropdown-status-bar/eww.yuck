
;; ──────────────────────────────────────────────
;; NOTES I LEARNED THE HARD WAY (PLEASE READ): 
;;   eww is a dynamic *widget* tool, but a 
;;   static *window* tool.
;;
;; - `defvar` variables are reactive: `eww update` 
;;   changes their value, and any `defwidget` that 
;;   references them will re-render automatically.
;;
;; - Variables cannot be used inside `defwindow` 
;;   (don’t waste time trying like I did).
;;
;; - Windows (`defwindow`) are static: geometry, 
;;   stacking, and `:exclusive` are fixed at parse-time.
;;
;; - We can only define "hitboxes" (the physical area it 
;;   takes up in e.g. Hyprland and displaces other windows) 
;;   at a per-window level — not in widgets themselves. 

;;   The hitbox always matches the size of its `defwindow` 
;;   size, never the widgets within the defwindow. Enabling 
;;   the hitbox of a window is done with `:exclusive true` 
;;   in the `defwindow`.

;;   Thus, widget state tend to use defvars (update live), 
;;   while window state only uses "function" arguments 
;;   (the square brackets []) and only at its creation...
;;   Is what I would say, but the latter part in eww v0.6
;;   isn't possible BECAUSE WINDOWS CAN'T USE ARGUMENTS.
;;
;; So for dynamic hitbox-sizing behaviour... 

;; 👉 I came up with the idea of two windows per entity:
;;      1. "its appearance, zero-hitbox window"
;;         (renders its appearance (+widgets), no hitbox space).
;;      2. "its hitbox, zero-appearance windows*"
;;         (no appearance, defines its hitbox space). *Not a typo,
;;         windows don't accept arguments, so we need to hardcode
;;         a new window for each hitbox size we ever want to switch
;;         to. Which I guess is like fighting games, but is a PAIN!
;;
;; e.g. making a status bar switch from taking up space to 
;;   taking up less/none(floating), without rerendering the 
;;   appearance by just destroying and recreating the hitbox 
;;   with a new hitbox size. This also means we can use defvars
;;   to change the appearance i.e. height of our entity without 
;;   destroying the appearance window entirely and rebuilding it.
;; ──────────────────────────────────────────────

; Variable to control whether the status bar reserves physical space and is visible
(defvar collapse_status_bar true)

(defwindow dropdown_status_bar_appearance
  :monitor 0
  :geometry (geometry :anchor "top center" ; Values include top, center, bottom and left, center, right.
                      :x      "0"          ; Position of the window. Values may be provided in px or %.
                      :y      "0"          ; Will be relative to anchor.
                      :width  "101%"
                      :height {false ? "25%" : "2.8%"})
  :stacking  "fg"     ; foreground - Possible values: fg, bg, overlay, bottom.
  :exclusive false  ; NO HITBOX FOR MY APPEARANCE WINDOW
  :focusable false  ; This is necessary for any widgets that use the keyboard to work.
  :opacity "1"  ; VISIBLE APPEARANCE WINDOW
  ; The widgets it contains listed below:
  (topbar :screen 0)
)

; (defwindow dropdown_status_bar_hitbox_normal
;   :monitor 0
;   :geometry (geometry :anchor "top center" ; Values include top, center, bottom and left, center, right.
;                       :x      "0"          ; Position of the window. Values may be provided in px or %.
;                       :y      "0"          ; Will be relative to anchor.
;                       :width  "101%"
;                       :height "2.8%")
;   :stacking  "bg"     ; background
;   :exclusive true  ; HITBOXES ON FOR MY HITBOX WINDOW
;   :opacity "0"  ; INVISIBLE HITBOX WINDOW
; )

(defwidget topbar [screen]
  (box :class "topbar"
       :valign "center"
       :halign "center"
       :width  "100%"
       :height "2.2%"
    ; (_buttons :shutdown "poweroff" :reboot "reboot"
    ;           :logout "loginctl kill-session self"
    ;           :shutdown_icon "󰐦" :reboot_icon "󰜉" :logout_icon "󰍂") ; TODO: 
    (clock)
    (_network :strength net :offline "󰤮" :excellent "󰤨" :good "󰤥" :okay "󰤢" :slow "󰤟")
    (battery :capacity {EWW_BATTERY["BAT0"]["capacity"]}
             :dfull  "[ 󱊣"
             :dmed   "[ 󱊢"
             :dlow   "[ 󱊡"
             :cfull  "[ 󱊦"
             :cmed   "[ 󱊥"
             :clow   "[ 󱊤"
             :cempty "[ 󰢟")
    ; (system_resources)
  )
)

; Battery
(defwidget battery [capacity dfull dmed dlow cfull cmed clow cempty]
  (box :class "battery"
       :space-evenly false
       :spacing 8
    (label :text { "${EWW_BATTERY["BAT0"]["status"]}" == "Discharging" ?
      (capacity < 33 ? dlow : capacity < 66 ? dmed : dfull) :
      (capacity < 17 ? cempty : capacity < 33 ? clow : capacity < 66 ? cmed : cfull) })
    (label :text "${capacity}% ]")
  )
)

; RAM
(defwidget system_resources []
  (box :class "system_resources"
    (system_progress
      :css "cpu"
      :tip "CPU ${round(EWW_CPU.avg,0)}%"
      :data {round(EWW_CPU.avg, 0)} 
      :icon ""
    )
    (system_progress
      :css "ram"
      :tip "RAM ${round(EWW_RAM.used_mem / 1048576, 2)}MB"
      :data {round(EWW_RAM.used_mem_perc, 0)}
      :icon "󰍛"
    )
    (system_progress
      :css "temp"
      :tip "Temperature ${EWW_TEMPS["CORETEMP_PACKAGE_ID_0"]}°C"
      :data {round(EWW_TEMPS.CORETEMP_PACKAGE_ID_0, 0)} 
      :icon ""
    )
  )
)
(defwidget system_progress [data icon css tip] 
  (box 
    :class "progress" 
    (circular-progress
      :class css
      :value data
      :thickness 8
      :tooltip tip
      (overlay
        :valign "center"
        (label 
          :class "icon" 
          :text icon
        )
      )
    )
  )
)

(defpoll net :interval "100s"
  :initial `N/A`
  `nmcli -t -f SIGNAL,ACTIVE device wifi \
    | awk -F':' '{if($2=="yes")print$1}'`)

(defwidget _network [strength offline excellent good okay slow]
  (box ; :class "net-box"
       ; :space-evenly false
       ; :spacing 8
    (label :text {strength == "" ? offline :
      strength < 26 ? slow :
        strength < 51 ? okay :
          strength < 76 ? good : excellent})))

(defwidget _buttons [shutdown shutdown_icon reboot
                    reboot_icon logout logout_icon]
  (box :class "btns-box" :spacing 5
       :vexpand true :hexpand true
       :valign "end" :halign "end"
       :space-evenly false
    (button :onclick shutdown shutdown_icon)
    (button :onclick reboot reboot_icon)
    (button :onclick logout logout_icon)))

; Time & Date
(defvar left_rev false)
(defwidget clock []
  (eventbox :class "date button" :cursor "pointer"
    :onclick {left_rev ? "eww update left_rev=false" : "eww update left_rev=true"}
    (box :class "date" :space-evenly false :spacing 10
      (box :class "clock" :space-evenly false :spacing 3
        (label :class "clock hour" :text {formattime(EWW_TIME, "%I")})
        (label :class "clock ellipsis" :text ":")
        (label :class "clock minute" :text {formattime(EWW_TIME, "%M")})
      )
      (image :class "distro" :path "./distro-logos/nixos-original.svg" :image-width 15 :image-height 15) ; how to make this dynamic?
      (label :class "today" :text {formattime(EWW_TIME, "%a %b %d ")})
    )
  )
)