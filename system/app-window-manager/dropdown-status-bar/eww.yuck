
;; ──────────────────────────────────────────────
;; NOTES I LEARNED THE HARD WAY (PLEASE READ): 
;;   eww is a dynamic *widget* tool, but a 
;;   static *window* tool.
;;
;; - `defvar` variables are reactive: `eww update` 
;;   changes their value, and any `defwidget` that 
;;   references them will re-render automatically.
;;
;; - Variables cannot be used inside `defwindow` 
;;   (don’t waste time trying like I did).
;;
;; - Windows (`defwindow`) are static: geometry, 
;;   stacking, and `:exclusive` are fixed at parse-time.
;;
;; - We can only define "hitboxes" (the physical area it 
;;   takes up in e.g. Hyprland and displaces other windows) 
;;   at a per-window level — not in widgets themselves. 

;;   The hitbox always matches the size of its `defwindow` 
;;   size, never the widgets within the defwindow. Enabling 
;;   the hitbox of a window is done with `:exclusive true` 
;;   in the `defwindow`.

;;   Thus, widget state tend to use variables (update live), 
;;   while window state only uses static "function" arguments.
;;
;; So for dynamic hitbox-sizing behaviour... 

;; 👉 I came up with the idea of two windows per entity:
;;      1. "its appearance, zero-hitbox window"
;;         (renders its appearance (+widgets), no hitbox space).
;;      2. "its hitbox, zero-appearance window*"
;;         (no appearance, defines its hitbox space).
;;
;; e.g. making a status bar switch from taking up space to 
;;   taking up less/none(floating), without re-rendering the 
;;   appearance by just destroying and recreating the hitbox 
;;   with a new hitbox size. This also means we can use defvars
;;   to change the appearance i.e. height of our entity without 
;;   destroying the appearance window entirely and rebuilding it.
;;
;; Other rules that aren't apparent:
;;   - If defining (not even launching) multiple windows in a file,
;;     to be a valid config, if the window areas overlap and one is
;;     :exclusive true, and the other is :exclusive false, then the
;;     the overlapping area will be exclusive (additive).
;;   - ALL WINDOWS MUST HAVE AT LEAST ONE (widget) INSIDE OR THE
;;     ENTIRE CONFIG WILL NOT COMPILE, EVEN IF YOU AREN"T LAUNCHING
;;     THAT WINDOW EVER! SO STUPID AND IS WHY I HAVE (box) WIDGETS.
;;   - To use variables to update more inherent widget properties
;;     like height, we need to use the `literal` defvar instead.
;;     For other stuff like switcing text in boxes, regular defvars.
;;     For periodic updates we'd use defpolls.
;; 
;; TODO: Contribute my suffering to the bare EWW docs. Also SCSS for opacity.
;; 
;; Kind regards, Charlie the Chud.
;; ──────────────────────────────────────────────

;; ──────────────────────────────────────────────
;; STATUS BAR STATE API (for NixOS modules to control)
;;
;; Pure state machine with memory + override:
;;
;; - baseBarMode = "collapsed" | "normal"
;;   Memory of the "true" state (fullscreen forces collapsed,
;;   leaving fullscreen restores normal, etc.).
;;
;; - isBarForcedExpanded = true | false
;;   Temporary override (omnibar, hover, etc.).e.g. when omnibar activated in fullscreen show it, but when omnibar disappear we still need to go back to the base fullscreen collapsed bar state
;;
;; ──────────────────────────────────────────────

(defvar baseBarMode "normal")
(defvar isBarForcedExpanded false)
;; ──────────────────────────────────────────────
;; APPEARANCE WINDOW (always lives, exclusive=false)
;; Sole purpose is to host the widgets inside, which react live to `defvar` variable changes.
;; (using `eww update myvar="10px"` to change the `defvar` variables)
;; ──────────────────────────────────────────────
(defwindow dropdown_status_bar_appearance []
  :monitor 0
  :geometry (geometry :anchor "top center"
                      :x      "0"
                      :y      "0"
                      :width  "101%"
                      ; :height auto fit to live bar-widget height
                      )
  :focusable false  ; This is necessary for any widgets that use the keyboard to work.
  :stacking "overlay"
  :exclusive false
  (literal :content {isBarForcedExpanded ? barContainerExpanded : baseBarMode == "normal" ? barContainerNormal : barContainerCollapsed})
)

(defwindow dropdown_status_bar_hitbox_normal []
  :monitor 0
  :geometry (geometry :anchor "top center" ; Values include top, center, bottom and left, center, right.
                      :x      "0"          ; Position of the window. Values may be provided in px or %.
                      :y      "0"          ; Will be relative to anchor.
                      :width  "101%"
                      :height "50%")
  :stacking  "fg"     ; foreground - needs to be in front to displace other windows
  :exclusive true  ; HITBOXES ON FOR MY HITBOX WINDOW
  ; The widgets it contains listed below:
  (box)  ; Minimal required empty content for a window in a config to compile
)

(defwidget barContainerCollapsed
  (box)
)

(defwidget barContainerNormal
  (box :valign "center"
       :halign "center"
       :width  "100%"
       :height "2.8%"
    (coreBarContent)
  )
)

(defwidget barContainerExpanded
  (box :valign "center"
       :halign "center"
       :width  "100%"
       :height "25%"
    (coreBarContent)
  )
)

; The core bar icons and stuff displayed when in normal or expanded, not in collapsed.
(defwidget coreBarContent
  (box :valign "center"
       :halign "center"
       :width  "100%"
       :height "2.8%"
    ; (_buttons :shutdown "poweroff" :reboot "reboot"
    ;           :logout "loginctl kill-session self"
    ;           :shutdown_icon "󰐦" :reboot_icon "󰜉" :logout_icon "󰍂") ; TODO: 
    (clock)
    (_network :strength net :offline "󰤮" :excellent "󰤨" :good "󰤥" :okay "󰤢" :slow "󰤟")
    (battery :capacity {EWW_BATTERY["BAT0"]["capacity"]}
             :dfull  "[ 󱊣"
             :dmed   "[ 󱊢"
             :dlow   "[ 󱊡"
             :cfull  "[ 󱊦"
             :cmed   "[ 󱊥"
             :clow   "[ 󱊤"
             :cempty "[ 󰢟")
    ; (system_resources)
  )
)

; Battery
(defwidget battery [capacity dfull dmed dlow cfull cmed clow cempty]
  (box :class "battery"
       :space-evenly false
       :spacing 8
    (label :text { "${EWW_BATTERY["BAT0"]["status"]}" == "Discharging" ?
      (capacity < 33 ? dlow : capacity < 66 ? dmed : dfull) :
      (capacity < 17 ? cempty : capacity < 33 ? clow : capacity < 66 ? cmed : cfull) })
    (label :text "${capacity}% ]")
  )
)

; RAM
(defwidget system_resources []
  (box :class "system_resources"
    (system_progress
      :css "cpu"
      :tip "CPU ${round(EWW_CPU.avg,0)}%"
      :data {round(EWW_CPU.avg, 0)} 
      :icon ""
    )
    (system_progress
      :css "ram"
      :tip "RAM ${round(EWW_RAM.used_mem / 1048576, 2)}MB"
      :data {round(EWW_RAM.used_mem_perc, 0)}
      :icon "󰍛"
    )
    (system_progress
      :css "temp"
      :tip "Temperature ${EWW_TEMPS["CORETEMP_PACKAGE_ID_0"]}°C"
      :data {round(EWW_TEMPS.CORETEMP_PACKAGE_ID_0, 0)} 
      :icon ""
    )
  )
)
(defwidget system_progress [data icon css tip] 
  (box 
    :class "progress" 
    (circular-progress
      :class css
      :value data
      :thickness 8
      :tooltip tip
      (overlay
        :valign "center"
        (label 
          :class "icon" 
          :text icon
        )
      )
    )
  )
)

(defpoll net :interval "100s"
  :initial `N/A`
  `nmcli -t -f SIGNAL,ACTIVE device wifi \
    | awk -F':' '{if($2=="yes")print$1}'`)

(defwidget _network [strength offline excellent good okay slow]
  (box ; :class "net-box"
       ; :space-evenly false
       ; :spacing 8
    (label :text {strength == "" ? offline :
      strength < 26 ? slow :
        strength < 51 ? okay :
          strength < 76 ? good : excellent})))

(defwidget _buttons [shutdown shutdown_icon reboot
                    reboot_icon logout logout_icon]
  (box :class "btns-box" :spacing 5
       :vexpand true :hexpand true
       :valign "end" :halign "end"
       :space-evenly false
    (button :onclick shutdown shutdown_icon)
    (button :onclick reboot reboot_icon)
    (button :onclick logout logout_icon)))

; Time & Date
(defvar left_rev false)
(defwidget clock []
  (eventbox :class "date button" :cursor "pointer"
    :onclick {left_rev ? "eww update left_rev=false" : "eww update left_rev=true"}
    (box :class "date" :space-evenly false :spacing 10
      (box :class "clock" :space-evenly false :spacing 3
        (label :class "clock hour" :text {formattime(EWW_TIME, "%I")})
        (label :class "clock ellipsis" :text ":")
        (label :class "clock minute" :text {formattime(EWW_TIME, "%M")})
      )
      (image :class "distro" :path "./distro-logos/nixos-original.svg" :image-width 15 :image-height 15) ; how to make this dynamic?
      (label :class "today" :text {formattime(EWW_TIME, "%a %b %d ")})
    )
  )
)